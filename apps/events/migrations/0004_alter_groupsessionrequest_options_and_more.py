# Generated by Django 5.2.5 on 2025-08-19 13:20

import datetime
import django.db.models.deletion
import django.db.models.expressions
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('events', '0003_create_default_sessions_index'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='groupsessionrequest',
            options={'permissions': [('approve_group_request', 'Approve group request')]},
        ),
        migrations.AlterModelOptions(
            name='peersessionrequest',
            options={'permissions': [('approve_peer_request', 'Approve peer request')]},
        ),
        migrations.RemoveConstraint(
            model_name='groupsession',
            name='group_ends_at_gte_starts_at',
        ),
        migrations.RemoveConstraint(
            model_name='groupsession',
            name='group_access_before_payment_price_zero',
        ),
        migrations.RemoveConstraint(
            model_name='peersession',
            name='peer_access_before_payment_price_zero',
        ),
        migrations.AlterField(
            model_name='groupsessiondetailpage',
            name='session',
            field=models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='page', to='events.groupsession'),
        ),
        migrations.AlterField(
            model_name='peersession',
            name='durations',
            field=models.CharField(help_text='These are durations (in minutes) that a session may be booked for', max_length=320),
        ),
        migrations.AlterField(
            model_name='peersessionavailability',
            name='occurrence',
            field=models.PositiveSmallIntegerField(blank=True, choices=[(0, 'Daily'), (1, 'Weekly'), (2, 'Monthly'), (3, 'Yearly')], null=True),
        ),
        migrations.AlterField(
            model_name='peersessionavailability',
            name='occurrence_ends_at',
            field=models.DateTimeField(help_text='This is the start of the date range during which the availability occurs. If occurrence is set and this field is not, the specified availbility will occur from the start date until forever.', null=True, verbose_name='Occurrence ends at'),
        ),
        migrations.AlterField(
            model_name='peersessiondetailpage',
            name='session',
            field=models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='page', to='events.peersession'),
        ),
        migrations.AddConstraint(
            model_name='groupsession',
            constraint=models.CheckConstraint(condition=models.Q(('ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=300)))), ('ends_at__lte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=7200))))), name='group_ends_at_gte_starts_at', violation_error_message='Group session must last between 5 and 120 minutes'),
        ),
        migrations.AddConstraint(
            model_name='groupsession',
            constraint=models.CheckConstraint(condition=models.Q(('price__gt', 0), ('access_before_payment', True), _connector='OR'), name='group_access_before_payment_price_zero', violation_error_message="Free sessions can't require access before payment"),
        ),
        migrations.AddConstraint(
            model_name='peersession',
            constraint=models.CheckConstraint(condition=models.Q(('price__gt', 0), ('access_before_payment', True), _connector='OR'), name='peer_access_before_payment_price_zero', violation_error_message="Free sessions can't require access before payment"),
        ),
        migrations.AddConstraint(
            model_name='peersessionavailability',
            constraint=models.CheckConstraint(condition=models.Q(('ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=300)))), ('ends_at__lte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(days=1))))), name='availability_ends_at_gte_starts_at', violation_error_message='Availabilty must last between 5 minutes and 1 day'),
        ),
        migrations.AddConstraint(
            model_name='peersessionavailability',
            constraint=models.CheckConstraint(condition=models.Q(('occurrence_starts_at__isnull', True), ('occurrence_ends_at__isnull', True), ('occurrence_ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('occurrence_starts_at'), '+', models.Value(datetime.timedelta(days=2)))), _connector='OR'), name='availability_occurrence_ends_at_gte_starts_at', violation_error_message="Availabilty occurrence must last at least two days. If you want an availability that does not recur, don't set any occurrence."),
        ),
    ]
