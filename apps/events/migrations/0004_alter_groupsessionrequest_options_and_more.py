# Generated by Django 5.2.5 on 2025-09-07 21:06

import datetime
import django.core.validators
import django.db.models.deletion
import django.db.models.expressions
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('events', '0003_create_default_sessions_index'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='groupsessionrequest',
            options={'permissions': [('approve_group_request', 'Approve group request')]},
        ),
        migrations.AlterModelOptions(
            name='peersessionrequest',
            options={'permissions': [('approve_peer_request', 'Approve peer request')]},
        ),
        migrations.RemoveConstraint(
            model_name='groupsession',
            name='group_ends_at_gte_starts_at',
        ),
        migrations.RemoveConstraint(
            model_name='groupsession',
            name='group_access_before_payment_price_zero',
        ),
        migrations.RemoveConstraint(
            model_name='peersession',
            name='peer_access_before_payment_price_zero',
        ),
        migrations.AddField(
            model_name='groupsessionrequest',
            name='pay_concessionary_price',
            field=models.BooleanField(default=False, help_text="You'll be able to pay a reduced price if the session peer approves."),
        ),
        migrations.AddField(
            model_name='peersessionrequest',
            name='pay_concessionary_price',
            field=models.BooleanField(default=False, help_text="You'll be able to pay a reduced price if the session peer approves."),
        ),
        migrations.AlterField(
            model_name='groupsession',
            name='concessionary_price',
            field=models.IntegerField(blank=True, help_text='Support seekers will be charged at this price if they are allowed to pay a reduced price', null=True, validators=[django.core.validators.MinValueValidator(0, message='Cannot charge negative values'), django.core.validators.MaxValueValidator(9999999, message="Cannot charge over 99,999 of a currency's unit. For higher values, try a different currency.")]),
        ),
        migrations.AlterField(
            model_name='groupsession',
            name='price',
            field=models.IntegerField(default=0, validators=[django.core.validators.MinValueValidator(0, message='Cannot charge negative values'), django.core.validators.MaxValueValidator(9999999, message="Cannot charge over 99,999 of a currency's unit. For higher values, try a different currency.")]),
        ),
        migrations.AlterField(
            model_name='groupsessiondetailpage',
            name='session',
            field=models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='page', to='events.groupsession'),
        ),
        migrations.AlterField(
            model_name='peersession',
            name='concessionary_per_hour_price',
            field=models.IntegerField(blank=True, help_text='Support seekers will be charged this price based on the duration of their requested session if set and if they are allowed to pay a reduced price', null=True, validators=[django.core.validators.MinValueValidator(0, message='Cannot charge negative values'), django.core.validators.MaxValueValidator(9999999, message="Cannot charge over 99,999 of a currency's unit. For higher values, try a different currency.")]),
        ),
        migrations.AlterField(
            model_name='peersession',
            name='concessionary_price',
            field=models.IntegerField(blank=True, help_text='Support seekers will be charged at this price if they are allowed to pay a reduced price', null=True, validators=[django.core.validators.MinValueValidator(0, message='Cannot charge negative values'), django.core.validators.MaxValueValidator(9999999, message="Cannot charge over 99,999 of a currency's unit. For higher values, try a different currency.")]),
        ),
        migrations.AlterField(
            model_name='peersession',
            name='durations',
            field=models.CharField(help_text='These are durations (in minutes) that a session may be booked for', max_length=320),
        ),
        migrations.AlterField(
            model_name='peersession',
            name='per_hour_price',
            field=models.IntegerField(blank=True, help_text='Support seekers will be charged this price based on the duration of their requested session if set', null=True, validators=[django.core.validators.MinValueValidator(0, message='Cannot charge negative values'), django.core.validators.MaxValueValidator(9999999, message="Cannot charge over 99,999 of a currency's unit. For higher values, try a different currency.")]),
        ),
        migrations.AlterField(
            model_name='peersession',
            name='price',
            field=models.IntegerField(default=0, validators=[django.core.validators.MinValueValidator(0, message='Cannot charge negative values'), django.core.validators.MaxValueValidator(9999999, message="Cannot charge over 99,999 of a currency's unit. For higher values, try a different currency.")]),
        ),
        migrations.AlterField(
            model_name='peersessionavailability',
            name='occurrence',
            field=models.PositiveSmallIntegerField(blank=True, choices=[(0, 'Daily'), (1, 'Weekly'), (2, 'Monthly')], null=True),
        ),
        migrations.AlterField(
            model_name='peersessionavailability',
            name='occurrence_ends_at',
            field=models.DateTimeField(help_text='This is the start of the date range during which the availability occurs. If occurrence is set and this field is not, the specified availbility will occur from the start date until forever.', null=True, verbose_name='Occurrence ends at'),
        ),
        migrations.AlterField(
            model_name='peersessiondetailpage',
            name='session',
            field=models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='page', to='events.peersession'),
        ),
        migrations.AddConstraint(
            model_name='groupsession',
            constraint=models.CheckConstraint(condition=models.Q(('ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=300)))), ('ends_at__lte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=7200))))), name='group_ends_at_gte_starts_at', violation_error_message='Group session must last between 5 and 120 minutes'),
        ),
        migrations.AddConstraint(
            model_name='groupsession',
            constraint=models.CheckConstraint(condition=models.Q(('price__gt', 0), ('access_before_payment', True), _connector='OR'), name='group_access_before_payment_price_zero', violation_error_message="Free sessions can't require access before payment"),
        ),
        migrations.AddConstraint(
            model_name='peersession',
            constraint=models.CheckConstraint(condition=models.Q(('price__gt', 0), ('access_before_payment', True), _connector='OR'), name='peer_access_before_payment_price_zero', violation_error_message="Free sessions can't require access before payment"),
        ),
        migrations.AddConstraint(
            model_name='peersessionavailability',
            constraint=models.CheckConstraint(condition=models.Q(('ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=300)))), ('ends_at__lte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(days=1))))), name='availability_ends_at_gte_starts_at', violation_error_message='Availabilty must last between 5 minutes and 1 day'),
        ),
        migrations.AddConstraint(
            model_name='peersessionavailability',
            constraint=models.CheckConstraint(condition=models.Q(('occurrence_starts_at__isnull', True), ('occurrence_ends_at__isnull', True), ('occurrence_ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('occurrence_starts_at'), '+', models.Value(datetime.timedelta(days=2)))), _connector='OR'), name='availability_occurrence_ends_at_gte_starts_at', violation_error_message="Availabilty occurrence must last at least two days. If you want an availability that does not recur, don't set any occurrence."),
        ),
        migrations.AlterConstraint(
            model_name='peersessionrequest',
            name='peer_ends_at_gte_starts_at',
            constraint=models.CheckConstraint(condition=models.Q(('ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=300))))), name='peer_ends_at_gte_starts_at', violation_error_message='Peer session must last at least 5 minutes'),
        ),
    ]
