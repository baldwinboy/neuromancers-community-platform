# Generated by Django 5.2.4 on 2025-07-26 14:35

import datetime
import django.core.validators
import django.db.models.deletion
import django.db.models.expressions
import re
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='GroupSession',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('title', models.CharField(max_length=320)),
                ('description', models.TextField(blank=True, null=True)),
                ('price', models.PositiveSmallIntegerField(default=0)),
                ('concessionary_price', models.PositiveSmallIntegerField(help_text='Support seekers will be charged at this price if they are allowed to pay a reduced price', null=True)),
                ('access_before_payment', models.BooleanField(default=True, help_text='Support seekers will be able to access the session before payment')),
                ('require_request_approval', models.BooleanField(default=True, help_text='Support seekers will require peer or admin approval before payment')),
                ('require_concessionary_approval', models.BooleanField(default=True, help_text='Support seekers will require peer or admin approval to access concessionary price')),
                ('require_refund_approval', models.BooleanField(default=True, help_text='Support seekers will require approval before payment is refunded')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('starts_at', models.DateTimeField()),
                ('ends_at', models.DateTimeField()),
                ('capacity', models.PositiveSmallIntegerField(default=1, help_text='Number of people that can attend at this time')),
                ('is_published', models.BooleanField(default=False)),
                ('meeting_link', models.URLField(blank=True, help_text='This will be automatically generated if not set', null=True)),
                ('host', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='group_sessions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='GroupSessionRequest',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('status', models.PositiveSmallIntegerField(choices=[(0, 'Approved'), (1, 'Rejected'), (2, 'Pending')], default=2, help_text='By default, this will be pending unless the session does not require approval, then it will be automatically approved. If the request is left pending until the start of the session, the request will be automatically rejected')),
                ('rejection_message', models.TextField(help_text='This message will be displayed to the attendee if their request is rejected if set', null=True)),
                ('stripe_payment_intent_id', models.CharField(help_text='This is set when the user pays for a session', max_length=320, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('attendee', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='group_session_requests', to=settings.AUTH_USER_MODEL)),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='requests', to='events.groupsession')),
            ],
        ),
        migrations.AddField(
            model_name='groupsession',
            name='support_seekers',
            field=models.ManyToManyField(blank=True, related_name='requested_sessions', through='events.GroupSessionRequest', to=settings.AUTH_USER_MODEL),
        ),
        migrations.CreateModel(
            name='PeerSession',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('title', models.CharField(max_length=320)),
                ('description', models.TextField(blank=True, null=True)),
                ('price', models.PositiveSmallIntegerField(default=0)),
                ('concessionary_price', models.PositiveSmallIntegerField(help_text='Support seekers will be charged at this price if they are allowed to pay a reduced price', null=True)),
                ('access_before_payment', models.BooleanField(default=True, help_text='Support seekers will be able to access the session before payment')),
                ('require_request_approval', models.BooleanField(default=True, help_text='Support seekers will require peer or admin approval before payment')),
                ('require_concessionary_approval', models.BooleanField(default=True, help_text='Support seekers will require peer or admin approval to access concessionary price')),
                ('require_refund_approval', models.BooleanField(default=True, help_text='Support seekers will require approval before payment is refunded')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('durations', models.CharField(help_text='These are durations (in minutes) that a session may be booked for', max_length=320, validators=[django.core.validators.RegexValidator(re.compile('^\\d+(?:,\\d+)*\\Z'), code='invalid', message='Only digits allowed')])),
                ('per_hour_price', models.PositiveSmallIntegerField(help_text='Support seekers will be charged this price based on the duration of their requested session if set', null=True)),
                ('concessionary_per_hour_price', models.PositiveSmallIntegerField(help_text='Support seekers will be charged this price based on the duration of their requested session if set and if they are allowed to pay a reduced price', null=True)),
                ('is_published', models.BooleanField(default=False, unique_for_date='starts_at')),
                ('host', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='peer_sessions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='PeerSessionAvailability',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('starts_at', models.DateTimeField(blank=True, null=True)),
                ('ends_at', models.DateTimeField(blank=True, null=True)),
                ('occurrence', models.PositiveSmallIntegerField(choices=[(0, 'Hourly'), (1, 'Daily'), (2, 'Weekly'), (3, 'Monthly'), (4, 'Yearly')], null=True)),
                ('occurrence_starts_at', models.DateTimeField(help_text='This is the start of the date range during which the availability occurs. If occurrence is set and this field is not, the specified availbility will occur forever.', null=True)),
                ('occurrence_ends_at', models.DateTimeField(null=True, verbose_name='This is the start of the date range during which the availability occurs. If occurrence is set and this field is not, the specified availbility will occur from the start date until forever.')),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='availability', to='events.peersession')),
            ],
        ),
        migrations.CreateModel(
            name='PeerSessionRequest',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('status', models.PositiveSmallIntegerField(choices=[(0, 'Approved'), (1, 'Rejected'), (2, 'Pending')], default=2, help_text='By default, this will be pending unless the session does not require approval, then it will be automatically approved. If the request is left pending until the start of the session, the request will be automatically rejected')),
                ('rejection_message', models.TextField(help_text='This message will be displayed to the attendee if their request is rejected if set', null=True)),
                ('stripe_payment_intent_id', models.CharField(help_text='This is set when the user pays for a session', max_length=320, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('starts_at', models.DateTimeField()),
                ('ends_at', models.DateTimeField()),
                ('attendee', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='peer_session_requests', to=settings.AUTH_USER_MODEL)),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='requests', to='events.peersession')),
            ],
        ),
        migrations.CreateModel(
            name='PeerScheduledSession',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('meeting_link', models.URLField(help_text='This will be automatically generated if not set', null=True)),
                ('request', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='scheduled_session', to='events.peersessionrequest')),
            ],
        ),
        migrations.AddConstraint(
            model_name='groupsessionrequest',
            constraint=models.UniqueConstraint(fields=('attendee', 'session'), name='unique_group_request'),
        ),
        migrations.AddConstraint(
            model_name='groupsession',
            constraint=models.UniqueConstraint(fields=('host', 'title', 'is_published'), name='unique_published_group_session'),
        ),
        migrations.AddConstraint(
            model_name='groupsession',
            constraint=models.CheckConstraint(condition=models.Q(('ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=300))))), name='group_ends_at_gte_starts_at', violation_error_message='Group session must last at least 5 minutes'),
        ),
        migrations.AddConstraint(
            model_name='groupsession',
            constraint=models.CheckConstraint(condition=models.Q(('access_before_payment', True), ('price', 0)), name='group_access_before_payment_price_zero', violation_error_message="Free sessions can't require access before payment"),
        ),
        migrations.AddConstraint(
            model_name='peersession',
            constraint=models.UniqueConstraint(fields=('host', 'title', 'is_published'), name='unique_published_peer_session'),
        ),
        migrations.AddConstraint(
            model_name='peersession',
            constraint=models.CheckConstraint(condition=models.Q(('access_before_payment', True), ('price', 0)), name='peer_access_before_payment_price_zero', violation_error_message="Free sessions can't require access before payment"),
        ),
        migrations.AddConstraint(
            model_name='peersessionavailability',
            constraint=models.UniqueConstraint(fields=('session', 'starts_at', 'occurrence_starts_at'), name='unique_peer_session_availability'),
        ),
        migrations.AddConstraint(
            model_name='peersessionrequest',
            constraint=models.UniqueConstraint(fields=('attendee', 'session', 'starts_at'), name='unique_peer_session_request'),
        ),
        migrations.AddConstraint(
            model_name='peersessionrequest',
            constraint=models.CheckConstraint(condition=models.Q(('ends_at__gte', django.db.models.expressions.CombinedExpression(models.F('starts_at'), '+', models.Value(datetime.timedelta(seconds=300))))), name='peer_ends_at_gte_starts_at', violation_error_message='Group session must last at least 5 minutes'),
        ),
    ]
